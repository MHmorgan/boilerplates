#!/usr/bin/env perl
#
#  ____                   
# |  _ \ ___   __ _ _   _ 
# | |_) / _ \ / _` | | | |
# |  _ < (_) | (_| | |_| |
# |_| \_\___/ \__, |\__,_|
#             |___/       
# 
# Personal assistant on mac systems.

# TODO:
# - Track call history in DATA
# - Add self update functionality

use 5.30.0;
use utf8;
use warnings;
use open qw(:std :utf8);
use strict;

use Getopt::Long;
use Pod::Usage;

BEGIN {
    push @INC, "$ENV{HOME}/lib";
}

use common;

#
# Application directories
#
our $HOME       = $ENV{"HOME"};
our $CACHE_DIR  = "$HOME/.cache/rogu";
our $CONF_DIR   = "$HOME/.config/rogu";
our $TMP_DIR    = "/tmp/rogu";

#
# Application files
#
our $USER_CONF_FILE = "$CONF_DIR/rogu.conf";
our $APP_DATA_FILE  = "$CONF_DIR/data";

#
# Oh-my-zsh parameters
#
our $OHMY_SCRIPT_URL = "https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh";
our $OHMY_DIR        = "$HOME/.oh-my-zsh";

#
# Dotfiles parameters
#
our $DOT_REPO   = "https://github.com/MHmorgan/dotfiles-mac.git";
our $DOT_DIR    = "$HOME/.dotfiles";
our $DOT_BRANCH = "main";

#
# Unified naming of common steps
#
our $TITLE_OH_MY_ZSH       = 'Oh-my-zsh üñ•';
our $TITLE_DOTFILES        = 'Dotfiles ‚öôÔ∏è';
our $TITLE_HOMEBREW        = 'Homebrew üç∫';
our $TITLE_BREW_APPS       = 'Brew-apps üçª';
our $TITLE_GET_TARGETS     = 'Get-targets üîß';
our $TITLE_INSTALL_TARGETS = 'Install-targets üîß';

#
# Other global parameters
#
our $DEFAULT_EDITOR = 'vi';
our $DEFAULT_PAGER  = 'less';



################################################################################
# Utils
#{{{

# trim STR ‚Üí STR
#
# Remove any leading and trailing whitespace
#
sub trim { shift =~ s/^\s+|\s+$//gr }


# Return true if the user has sudo privileges.
# Stolen from Homebrew's install script.
#
sub user_can_sudo {
    qx{ command -v sudo } or return 0;
    system q(! LANG= sudo -n -v 2>&1 | grep -q "may not run sudo");
    $? == 0 ? 1 : 0
}


# Have a user select values of a list, returning
# the modified list.
#
sub list_select {
    my ($desc, @values) = @_;
    #
    # Fill temporary file with list.
    #
    my $tmp_file = "/tmp/rogu/" . time;
    open(my $fh, ">", $tmp_file) or die "opening tmp file: $!";
    say $fh "# $desc";
    say $fh join("\n", @values);
    close $fh;
    #
    # Have the user edit the list.
    #
    my $editor = $ENV{'EDITOR'} // $DEFAULT_EDITOR;
    system "$editor $tmp_file";
    #
    # Return the modified list.
    #
    open($fh, "<", $tmp_file) or die "opening tmp file: $!";
    my @new_values;
    while (<$fh>) {
        chomp;
        next if /^(#|\s*%)/;
        push @new_values, $_;
    }
    close $fh;
    unlink $tmp_file;
    return @new_values;
}

sub run {
    my $cmd = shift;
    say "[>] $cmd";
    system $cmd;
    return $? == 0;
}
#}}}


################################################################################
# Oh-my-zsh
#{{{


# Return the root directory for the Oh-my-zsh installation
# or undef if it cannot be found.
#
sub ohmy_root { -d $OHMY_DIR ? $OHMY_DIR : undef }


# Return a list of all custom plugins/themes for Oh-my-zsh.
#
sub ohmy_custom {
    my @vals;
    my $root = ohmy_root() // return @vals;
    chdir "$root/custom" || die $!;

    while (<plugins/* themes/*>) {
        next if /example/;
        push @vals, $_;
    }
    return @vals;
}
#}}}


################################################################################
# Configurations
#
# User data configuration routines.
#
# The user configuration data structure looks like:
#
# {
#     <section name> => {
#         'DIR' => <workdir>
#         'RUN' => <command>
#         'CHECK => <command>
#         'DATA' => ( <list of data lines> )
#     }
# }
#
# Where all subsections are optional and may be undef.
#
#{{{


sub config {
    $_ = shift || die "Missing subcommand ‚úó\n";
    return conf_print(\%::CONF)    if /print/;
    return conf_validate(\%::CONF) if /validate/;
    die "Unknown subcommand: $_ üö´\n";
}


# Read and parse the given file into the user configuration data
# structure.
#
sub conf_read {
    my ($fname) = @_;

    my $text;
    open(my $cfile, "<", $fname) or die qq(opening "$fname": $!);
    while (<$cfile>) {
        # Skip empty lines and comments
        next if /^(#(?!!).*|\s*)$/;
        # Remove leading whitespace and escaped newlines
        s/\\\n//g;
        $text .= $_;
    }
    close $cfile;

    my %conf;
    my $sect;
    for (split /\n/, $text) {
        #
        # New section with optional work directory.
        #
        if (/^\[(.*?(@(.*))?)\]/) {
            $sect = {};
            $conf{trim($1)} = $sect;
            if (defined $3) {
                $sect->{'DIR'} = trim($3 =~ s/~/$HOME/r);
            }
        }
        #
        # Non-data content of a section.
        #
        elsif (/^([A-Z]+): (.*)$/) {
            $sect->{$1} = trim($2);
        }
        #
        # Data content of a section.
        #
        else {
            push @{$sect->{'DATA'}}, trim($_);
        }
    }

    return %conf;
}


# Print the given user config data structure.
#
sub conf_print {
    my ($conf) = @_;

    if (!$conf) {
        say "<empty config>";
        return
    }

    for my $name (sort keys %{$conf}) {
        header $name;
        my $sect = $conf->{$name};
        for (keys %{$sect}) {
            say bold "$_:";
            my $val = $sect->{$_};
            if (ref($val) =~ m/ARRAY/) {
                say join("\n", @{$val});
            } else {
                say $val;
            }
        }
    }
}

# Validates the sections and subsections of the given user
# configuration data.
#
sub conf_validate {
    my ($conf) = @_;

    my %sections = (
        Get         => [ 'DIR', 'DATA' ],
        Install     => [ 'DIR', 'DATA', 'CHECK' ],
        Homebrew    => [ 'DATA' ]
    );

    for my $sec_name (keys %{$conf}) {
        $sec_name =~ /^(\w+)/;
        my $sec_type = $1;
        #
        # Validate section type.
        #
        unless (exists $sections{$sec_type}) {
            say red qq/($sec_name) Unknown section type "$sec_type"/;
            next;
        }
        my %subsec = %{$conf->{$sec_name}};
        #
        # Validate subsections.
        #
        my %sec_cnt;
        $sec_cnt{$_} += 1 for @{$sections{$sec_type}};
        $sec_cnt{$_} -= 1 for keys %{$conf->{$sec_name}};
        while (my ($sec, $cnt) = each %sec_cnt) {
            say yellow qq/($sec_name) Missing subsection "$sec"/
                if $cnt == 1;
            say yellow qq/($sec_name) Unknown subsection "$sec"/
                if $cnt == -1;
        }
        #
        # Check directory existence
        #
        if (exists $subsec{DIR}) {
            my $dir = $subsec{DIR};
            say yellow qq/($sec_name) Directory not found "$dir"/
                unless -d $dir;
        }
    }
}


# Run the CHECK command for a given target, returning true
# if the check passes.
#
sub conf_run_check {
    my ($name) = @_;
    unless (exists $::CONF{$name}) {
        die "Target [$name] not found";
    }
    chdir $::CONF{$name}->{DIR} or return 0;
    my $check = $::CONF{$name}->{CHECK} // return 0;
    system $check;
    $? == 0 ? 1 : 0
}
#}}}


################################################################################
# Dotfiles
#{{{


# Return the root directory for the dotfiles repo, or undef
# if it cannot be found.
#
sub dot_root { -d $DOT_DIR ? $DOT_DIR : undef }


# Return the git command needed to interact with the
# dotfiles repo.
#
sub dot_git {
    my $root = dot_root() // return undef;
    return "git --git-dir=$root --work-tree=$HOME";
}


# Return a list of all tracked dotfiles.
#
sub dot_files {
    my @files;
    my $git = dot_git() // return @files;
    chdir() or die $?;
    @files = qx{ $git ls-tree -r --name-only $DOT_BRANCH }
        or die "ls-tree failed";
    chomp(@files);
    return @files;
}
#}}}


################################################################################
# Homebrew
#{{{
#}}}


################################################################################
# Install
#
# The installation does the following:
#
# - Clones and installs my dotfiles from github.
# - Installs homebrew, adds taps and installs brew applications. 
# - Runs 'Install' config tasks
# - Runs 'Get' config tasks
#
#{{{

sub install {
    qx{ which git } or die "Git is not installed!\n";
    qx{ which zsh } or die "Zsh is not installed!\n";

    my @steps = (
        $TITLE_OH_MY_ZSH,
        $TITLE_DOTFILES,
    );
    @steps = list_select "Remove any installation steps to skip.", @steps;

    my $run_step = sub {
        my ($name, $func) = @_;
        return unless grep /$name/, @steps;
        header $name;
        sleep 1;
        &$func();
        print "\n";
        sleep 1;
    };

    &$run_step($TITLE_OH_MY_ZSH,        \&inst_oh_my_zsh);
    &$run_step($TITLE_DOTFILES,         \&inst_dotfiles);
    &$run_step($TITLE_HOMEBREW,         \&inst_homebrew);
    &$run_step($TITLE_BREW_APPS,        \&inst_brew_apps);
    &$run_step($TITLE_GET_TARGETS,      \&inst_get_targets);
    &$run_step($TITLE_INSTALL_TARGETS,  \&inst_install_targets);
}


# Install Oh My Zsh, unless it is already installed.
#
sub inst_oh_my_zsh {
    if (defined ohmy_root) {
        good "Already installed!";
        return;
    }

    chdir() or die $!;
    run qq(sh -c "RUNZSH=no \$(curl -fsSL $OHMY_SCRIPT_URL)")
        or die "Oh no!\n";

    unless (defined ohmy_root) {
        err "Oh-my-zsh installation not found by Rogu ‚ö†Ô∏è";
    }

    my $backup = '.zshrc.pre-oh-my-zsh';
    if (-e $backup) {
        info qq(Looks like oh-my-zsh has moved your ".zshrc" to "$backup");
        run "mv $backup .zshrc" if confirm "Do you want to undo this?";
    }

    good affirmative;
}


sub inst_dotfiles {
    if (defined dot_root) {
        good "Already installed!";
        return;
    }

    chdir() or die $!;
    run "git clone --bare $DOT_REPO $DOT_DIR" or die "Oh no!\n";

    info "Creating backup of any existing dotfiles...";
    for (dot_files) {
        run "mv $_ $_~" if -e;
    }

    my $git = dot_git;
    run "$git checkout $DOT_BRANCH" or die "Oh no!\n";
    run "$git config branch.$DOT_BRANCH.remote origin";
    run "$git config branch.$DOT_BRANCH.merge refs/heads/$DOT_BRANCH";
}


sub inst_homebrew {
    #TODO When I get a new mac ‚ùóÔ∏è
}


sub inst_brew_apps {
    my $data = $::CONF{'Homebrew Apps'}{'DATA'}
        // [ "# (No Homebrew apps defined in user config)" ];

    my @apps = list_select(
        "Select which homebrew applications to install.",
        @{$data}
    );
    say join "\n", @apps;

    #TODO When I get a new mac ‚ùóÔ∏è
}


sub inst_get_targets {
    #TODO
}


sub inst_install_targets {
    #TODO
}
#}}}


################################################################################
# Uninstall
#
# Does everything inverse of what the Install
# operations does.
#
#{{{

sub uninstall {
    my @steps = (
        $TITLE_OH_MY_ZSH,
        $TITLE_DOTFILES,
    );
    @steps = list_select "Remove any uninstallation steps to skip.", @steps;

    my $run_step = sub {
        my ($name, $func) = @_;
        return unless grep /$name/, @steps;
        header $name;
        sleep 1;
        &$func();
        print "\n";
        sleep 1;
    };

    &$run_step($TITLE_OH_MY_ZSH,        \&unin_oh_my_zsh);
    &$run_step($TITLE_DOTFILES,         \&unin_dotfiles);
    &$run_step($TITLE_HOMEBREW,         \&unin_homebrew);
    &$run_step($TITLE_BREW_APPS,        \&unin_brew_apps);
    # &$run_step($TITLE_GET_TARGETS,      \&unin_get_targets);
    # &$run_step($TITLE_INSTALL_TARGETS,  \&unin_install_targets);
}


sub unin_oh_my_zsh {
    my $root = ohmy_root()
        // die "Oh-my-zsh is not installed ‚ö†Ô∏è\n";

    my @custom = ohmy_custom;
    if (@custom) {
        warn "You have custom plugins/themes\n";
        say " - $_" for @custom;
        return if confirm "Abort uninstallation of oh-my-zsh?";
    }

    run "rm -rf $root" or die "Oh no!";

    good affirmative;
}


sub unin_dotfiles {
    my $root = dot_root()
        // die "Dotfiles is not installed ‚ö†Ô∏è";
    my @dotfiles = dot_files;

    run "rm -rf $root" or die "Oh no!\n";

    if (@dotfiles) {
        info "Found " . scalar @dotfiles . " tracked dotfiles.";
        say for @dotfiles;
        if (confirm "Do you want to delete these?") {
            run "rm $_" for @dotfiles;
        }
    }

    good affirmative;
}


sub unin_homebrew {
    confirm yellow "Are you suuure you want to uninstall Homebrew?"
        or return;
    confirm yellow bold "Are you 100% absolutely definetly positively sure you want to uninstall Homebrew?"
        or return;

    #TODO When I get a new mac ‚ùóÔ∏è
}


sub unin_brew_apps {
    my @apps;
    confirm yellow "Are you completely sure you want to uninstall Homebrew applications?"
        or return;

    #TODO When I get a new mac ‚ùóÔ∏è
}
#}}}


################################################################################
# Doctor
#{{{

sub doctor {
    my $run_step = sub {
        my ($name, $func) = @_;
        header $name;
        sleep 1;
        &$func();
        print "\n";
        sleep 1;
    };

    &$run_step($TITLE_OH_MY_ZSH,        \&doc_oh_my_zsh);
    &$run_step($TITLE_DOTFILES,         \&doc_dotfiles);
    &$run_step($TITLE_HOMEBREW,         \&doc_homebrew);
    # &$run_step($TITLE_BREW_APPS,        \&doc_brew_apps);
    # &$run_step($TITLE_GET_TARGETS,      \&doc_get_targets);
    &$run_step($TITLE_INSTALL_TARGETS,  \&doc_install_targets);
}


sub doc_oh_my_zsh {
    #
    # Is install script URL valid?
    #
    my $script_head = qx{ curl -sSL --head $OHMY_SCRIPT_URL };
    if ($script_head =~ /HTTP.. 2\d\d/) {
        say "Install script URL is valid.";
    } else {
        say red "Install script URL is invalid üö´";
        say "HEAD $script_head";
        say $script_head;
    }
    #
    # Is oh-my-zsh installed?
    #
    my $root = ohmy_root;
    unless (defined $root) {
        say red "Oh-my-zsh isn't installed üëé";
        return;
    }
    say green "Oh-my-zsh is installed üëç";
    say "Location: $root";
    #
    # List custom plugins/themes.
    #
    my @custom = ohmy_custom;
    if (@custom) {
        say "You have " . scalar @custom . " custom plugins/themes:";
        say "  $_" for @custom;
    }
}


sub doc_dotfiles {
    #
    # Is repo URL valid?
    #
    my $repo_head = qx{ curl -sSL --head $DOT_REPO };
    if ($repo_head =~ /HTTP.. 2\d\d/) {
        say "Dotfiles repo URL is valid.";
    } else {
        say red "Dotfiles repo URL is invalid üö´";
        say "HEAD $DOT_REPO";
        say $repo_head;
    }
    #
    # Is dotfiles installed?
    #
    my $root = dot_root;
    unless (defined $root) {
        say red "Dotfiles isn't installed üëé";
        return;
    }
    say green "Dotfiles is installed üëç";
    say "Location: $root";
    #
    # List dotfiles
    #
    my @dotfiles = dot_files;
    say "Tracking " . scalar @dotfiles . " dotfiles.";
    if (@dotfiles) {
        say bold "Dotfiles";
        say "  $_" for @dotfiles;
    }
    #
    # Git status/update
    #
    chdir() or die $!;
    my $git = dot_git;
    my $status = qx{ $git status --short };
    if ($status eq '') {
        say bold "Updating dotfiles repo";
        system "$git pull";
    } else {
        say bold "Repo Status:";
        system "$git status";
        say yellow "Cannot update dirty dotfiles ‚õîÔ∏è";
    }
}


sub doc_homebrew {
    #
    # Is installed?
    #
    chomp(my $exec = qx{ command -v brew });
    if ($exec eq '') {
        say red "Homebrew isn't installed üëé";
        return;
    }
    say green "Homebrew is installed üëç";
    say "Executable location: $exec";
    #
    # Homebrew's environment variable.
    #
    say bold "Variables";
    chomp(my @vars = qx{ env });
    say for grep /HOMEBREW/, @vars;
    #
    # Homebrew information
    #
    say bold "Information";
    system "brew info";
    system "brew update";
}


sub doc_install_targets {
    my @targets = grep /^Install/, keys %::CONF;
    for (@targets) {
        my $installed = conf_run_check $_;
        if ($installed) {
            say green qq(Installed: [$_] üëç);
        } else {
            say yellow qq(Not installed: [$_] üëé);
        }
    }
}
#}}}


################################################################################
# Data
#{{{
#}}}


################################################################################
# Main
#{{{

mkdir "$HOME/.cache", 0755 unless -d "$HOME/.cache";
mkdir "$HOME/.config", 0755 unless -d "$HOME/.config";
mkdir $CACHE_DIR, 0755 unless -d $CACHE_DIR;
mkdir $CONF_DIR, 0755 unless -d $CONF_DIR;
mkdir $TMP_DIR, 0755 unless -d $TMP_DIR;

dbmopen(our %DATA, $APP_DATA_FILE, 0644);

our %CONF;
%CONF = conf_read $USER_CONF_FILE if -f $USER_CONF_FILE;

# Rogu is only intended to be used interactively, so
# don't bother with using both STDERR and STDOUT.
# The output shouldn't be redirected anyway.
set_log_out(*STDOUT);

my $MAN = 0;
my $HELP = 0;
my $DEBUG = 0;

GetOptions('help|h' => \$HELP, 'man' => \$MAN, 'debug|d', \$DEBUG)
    or pod2usage(2);
pod2usage( -exitval  => 0, -verbose  => 2)
    if $MAN;
pod2usage( -verbose  => 99, -sections => "SYNOPSIS|Commands|OPTIONS")
    if $HELP || !(scalar @ARGV);

my $CMD = shift;
my $ARGS = join '", "', @ARGV;
my @RES = eval "$CMD(\"$ARGS\")";
if ($DEBUG && @RES) {
    use Data::Dumper;
    say Dumper(@RES);
}
#}}}


################################################################################
# Help text
#{{{

__END__
=head1 NAME

rogu - Roger's weird offspring.


=head1 SYNOPSIS

rogu [options] <command> [args...]


=head1 Commands

=over 8

=item B<config> <cmd>

User configuration actions.

Subcommands: print, validate.

=item B<doctor>

Run an sanity check of everything Rogu knows about on the
system. This is mostly a passive action, but not completely.

=item B<install>

Install everything needed to use the system (at least
everything Rogu knows about).

=item B<uninstall>

Uninstall most of the things that Rogu knows how to handle.

=back


=head1 OPTIONS

=over 8


=item B<--help>

Print a brief help message and exits.


=item B<--man>

Prints the manual page and exits.

=back


=head1 DESCRIPTION

Bla bla bla... Rogu's awesome.

=cut #}}}
