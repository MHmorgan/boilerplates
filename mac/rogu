#!/usr/bin/env perl
#
#  ____                   
# |  _ \ ___   __ _ _   _ 
# | |_) / _ \ / _` | | | |
# |  _ < (_) | (_| | |_| |
# |_| \_\___/ \__, |\__,_|
#             |___/       
# 
# Personal assistant on mac systems.

# TODO:
# - Track history in DATA

use 5.30.0;
use utf8;
use warnings;
use open qw(:std :utf8);
use strict;

use Getopt::Long;
use Pod::Usage;

BEGIN {
    push @INC, "$ENV{HOME}/lib";
}

use common;

#
# Application directories
#
our $HOME       = $ENV{"HOME"};
our $CACHE_DIR  = "$HOME/.cache/rogu";
our $CONF_DIR   = "$HOME/.config/rogu";
our $TMP_DIR    = "/tmp/rogu";

#
# Application files
#
our $USER_CONF_FILE = "$CONF_DIR/rogu.conf";
our $APP_DATA_FILE  = "$CONF_DIR/data";

#
# Oh-my-zsh parameters
#
our $OHMY_SCRIPT_URL = "https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh";
our $OHMY_DIR        = "$HOME/.oh-my-zsh";

#
# Dotfiles parameters
#
our $DOT_REPO   = "https://github.com/MHmorgan/dotfiles-mac.git";
our $DOT_DIR    = "$HOME/.dotfiles";
our $DOT_BRANCH = "main";

#
# Unified naming of common steps
#
our $TITLE_OH_MY_ZSH       = 'Oh-my-zsh üñ•';
our $TITLE_DOTFILES        = 'Dotfiles ‚öôÔ∏è';
our $TITLE_HOMEBREW        = 'Homebrew üç∫';
our $TITLE_BREW_APPS       = 'Brew-apps üçª';
our $TITLE_GET_TARGETS     = 'Get-targets üîß';
our $TITLE_INSTALL_TARGETS = 'Install-targets üîß';

#
# Other global parameters
#
our $DEFAULT_EDITOR = 'vi';
our $DEFAULT_PAGER  = 'less';



################################################################################
# Utils
#{{{

# trim STR ‚Üí STR
#
# Remove any leading and trailing whitespace
#
sub trim { shift =~ s/^\s+|\s+$//gr }


# Return true if the user has sudo privileges.
# Stolen from Homebrew's install script.
#
sub user_can_sudo {
    qx{ command -v sudo } or return 0;
    # The following command has 3 parts:
    #
    # 1. Run `sudo` with `-v`. Does the following:
    #    ‚Ä¢ with privilege: asks for a password immediately.
    #    ‚Ä¢ without privilege: exits with error code 1 and prints the message:
    #      Sorry, user <username> may not run sudo on <hostname>
    #
    # 2. Pass `-n` to `sudo` to tell it to not ask for a password. If the
    #    password is not required, the command will finish with exit code 0.
    #    If one is required, sudo will exit with error code 1 and print the
    #    message:
    #    sudo: a password is required
    #
    # 3. Check for the words "may not run sudo" in the output to really tell
    #    whether the user has privileges or not. For that we have to make sure
    #    to run `sudo` in the default locale (with `LANG=`) so that the message
    #    stays consistent regardless of the user's locale.
    #
    system q(! LANG= sudo -n -v 2>&1 | grep -q "may not run sudo");
    $? == 0 ? 1 : 0
}


# list_select DESC VAL...
#
# Have a user select values of a list, returning
# the modified list.
#
sub list_select {
    my ($desc, @values) = @_;
    #
    # Fill temporary file with list.
    #
    my $tmp_file = "/tmp/rogu/" . time;
    open(my $fh, ">", $tmp_file) or die "opening tmp file: $!";
    say $fh "# $desc";
    say $fh join("\n", @values);
    close $fh;
    #
    # Have the user edit the list.
    #
    my $editor = $ENV{'EDITOR'} // $DEFAULT_EDITOR;
    system "$editor $tmp_file";
    #
    # Return the modified list.
    #
    open($fh, "<", $tmp_file) or die "opening tmp file: $!";
    my @new_values;
    while (<$fh>) {
        chomp;
        next if /^(#|\s*%)/;
        push @new_values, $_;
    }
    close $fh;
    unlink $tmp_file;
    return @new_values;
}

sub run {
    my $cmd = shift;
    say "[>] $cmd";
    system $cmd;
    return $? == 0;
}
#}}}


################################################################################
# Oh-my-zsh
#{{{


# Return the root directory for the Oh-my-zsh installation
# or undef if it cannot be found.
#
sub ohmy_root { -d $OHMY_DIR ? $OHMY_DIR : undef }


# Return a list of all custom plugins/themes for Oh-my-zsh.
#
sub ohmy_custom {
    my @vals;
    my $root = ohmy_root() // return @vals;
    chdir "$root/custom" || die $!;

    while (<plugins/* themes/*>) {
        next if /example/;
        push @vals, $_;
    }
    return @vals;
}
#}}}


################################################################################
# Dotfiles
#{{{


# Return the root directory for the dotfiles repo, or undef
# if it cannot be found.
#
sub dot_root { -d $DOT_DIR ? $DOT_DIR : undef }


# Return the git command needed to interact with the
# dotfiles repo.
#
sub dot_git {
    my $root = dot_root() // return undef;
    return "git --git-dir=$root --work-tree=$HOME";
}


# Return a list of all tracked dotfiles.
#
sub dot_files {
    my @files;
    my $git = dot_git() // return @files;
    chdir() or die $?;
    chomp(@files = qx{ $git ls-tree -r --name-only $DOT_BRANCH });
    return @files;
}
#}}}


################################################################################
# Install
#
# The installation does the following:
#
# - Clones and installs my dotfiles from github.
# - Installs homebrew, adds taps and installs brew applications. 
# - Runs 'Install' config tasks
# - Runs 'Get' config tasks
#
#{{{

sub install {
    qx{ which git } or die "Git is not installed!\n";
    qx{ which zsh } or die "Zsh is not installed!\n";

    my @steps = (
        $TITLE_OH_MY_ZSH,
        $TITLE_DOTFILES,
    );
    @steps = list_select "Remove any installation steps to skip.", @steps;

    my $run_step = sub {
        my ($name, $func) = @_;
        return unless grep /$name/, @steps;
        header $name;
        sleep 1;
        &$func();
        print "\n";
        sleep 1;
    };

    &$run_step($TITLE_OH_MY_ZSH,        \&inst_oh_my_zsh);
    &$run_step($TITLE_DOTFILES,         \&inst_dotfiles);
    &$run_step($TITLE_HOMEBREW,         \&inst_homebrew);
    &$run_step($TITLE_BREW_APPS,        \&inst_brew_apps);
    &$run_step($TITLE_GET_TARGETS,      \&inst_get_targets);
    &$run_step($TITLE_INSTALL_TARGETS,  \&inst_install_targets);
}


# Install Oh My Zsh, unless it is already installed.
#
sub inst_oh_my_zsh {
    if (defined ohmy_root) {
        good "Already installed!";
        return;
    }

    chdir() or die $!;
    run qq(sh -c "RUNZSH=no \$(curl -fsSL $OHMY_SCRIPT_URL)")
        or die "Oh no!\n";

    unless (defined ohmy_root) {
        err "Oh-my-zsh installation not found by Rogu ‚ö†Ô∏è";
    }

    my $backup = '.zshrc.pre-oh-my-zsh';
    if (-e $backup) {
        info qq(Looks like oh-my-zsh has moved your ".zshrc" to "$backup");
        run "mv $backup .zshrc" if confirm "Do you want to undo this?";
    }

    good affirmative;
}


sub inst_dotfiles {
    if (defined dot_root) {
        good "Already installed!";
        return;
    }

    chdir() or die $!;
    run "git clone --bare $DOT_REPO $DOT_DIR" or die "Oh no!\n";

    info "Creating backup of any existing dotfiles...";
    for (dot_files) {
        run "mv $_ $_~" if -e;
    }

    my $git = dot_git;
    run "$git checkout $DOT_BRANCH" or die "Oh no!\n";
    run "$git config branch.$DOT_BRANCH.remote origin";
    run "$git config branch.$DOT_BRANCH.merge refs/heads/$DOT_BRANCH";
}


sub inst_homebrew {
    #TODO
}


sub inst_brew_apps {
    my $data = $::CONF{'Homebrew Apps'}{'DATA'}
        // [ "# (No Homebrew apps defined in user config)" ];

    my @apps = list_select(
        "Select which homebrew applications to install.",
        @{$data}
    );
    say join "\n", @apps;
    #TODO
}


sub inst_get_targets {
    #TODO
}


sub inst_install_targets {
    #TODO
}
#}}}


################################################################################
# Uninstall
#
# Does everything inverse of what the Install
# operations does.
#
#{{{

sub uninstall {
    my @steps = (
        $TITLE_OH_MY_ZSH,
        $TITLE_DOTFILES,
    );
    @steps = list_select "Remove any uninstallation steps to skip.", @steps;

    my $run_step = sub {
        my ($name, $func) = @_;
        return unless grep /$name/, @steps;
        header $name;
        sleep 1;
        &$func();
        print "\n";
        sleep 1;
    };

    &$run_step($TITLE_OH_MY_ZSH,        \&unin_oh_my_zsh);
    &$run_step($TITLE_DOTFILES,         \&unin_dotfiles);
    # &$run_step($TITLE_HOMEBREW,         \&unin_homebrew);
    # &$run_step($TITLE_BREW_APPS,        \&unin_brew_apps);
    # &$run_step($TITLE_GET_TARGETS,      \&unin_get_targets);
    # &$run_step($TITLE_INSTALL_TARGETS,  \&unin_install_targets);
}


sub unin_oh_my_zsh {
    my $root = ohmy_root()
        // die "Oh-my-zsh is not installed ‚ö†Ô∏è\n";

    my @custom = ohmy_custom;
    if (@custom) {
        warn "You have custom plugins/themes\n";
        say " - $_" for @custom;
        return if confirm "Abort uninstallation of oh-my-zsh?";
    }

    run "rm -rf $root" or die "Oh no!";

    good affirmative;
}


sub unin_dotfiles {
    my $root = dot_root()
        // die "Dotfiles is not installed ‚ö†Ô∏è";
    my @dotfiles = dot_files;

    run "rm -rf $root" or die "Oh no!\n";

    if (@dotfiles) {
        info "Found " . scalar @dotfiles . " tracked dotfiles.";
        say for @dotfiles;
        if (confirm "Do you want to delete these?") {
            run "rm $_" for @dotfiles;
        }
    }

    good affirmative;
}


sub unin_homebrew {
    confirm yellow "Are you suuure you want to uninstall Homebrew?"
        or return;
    confirm yellow bold "Are you 100% absolutely definetly positively sure you want to uninstall Homebrew?"
        or return;
    #TODO
}

sub unin_brew_apps {
    my @apps;
    confirm yellow "Are you completely sure you want to uninstall Homebrew applications?"
        or return;
    #TODO
}
#}}}


################################################################################
# Doctor
#{{{

sub doctor {
    my $run_step = sub {
        my ($name, $func) = @_;
        header $name;
        sleep 1;
        &$func();
        print "\n";
        sleep 1;
    };

    &$run_step($TITLE_OH_MY_ZSH,        \&doc_oh_my_zsh);
    &$run_step($TITLE_DOTFILES,         \&doc_dotfiles);
    # &$run_step($TITLE_HOMEBREW,         \&doc_homebrew);
    # &$run_step($TITLE_BREW_APPS,        \&doc_brew_apps);
    # &$run_step($TITLE_GET_TARGETS,      \&doc_get_targets);
    # &$run_step($TITLE_INSTALL_TARGETS,  \&doc_install_targets);
}


sub doc_oh_my_zsh {
    #
    # Is install script URL valid?
    #
    my $script_head = qx{ curl -sSL --head $OHMY_SCRIPT_URL };
    if ($script_head =~ /HTTP.. 2\d\d/) {
        info "Install script URL is valid.";
    } else {
        bad "Install script URL is invalid.";
        say "HEAD $script_head";
        say $script_head;
    }
    #
    # Is oh-my-zsh installed?
    #
    my $root = ohmy_root;
    unless (defined $root) {
        bad "Oh-my-zsh isn't installed üëé";
        return;
    }
    good "Oh-my-zsh is installed üëç";
    info "Location: $root";
    #
    # List custom plugins/themes.
    #
    my @custom = ohmy_custom;
    if (@custom) {
        info "You have " . scalar @custom . " custom plugins/themes:";
        say " - $_" for @custom;
    }
}


sub doc_dotfiles {
    #
    # Is repo URL valid?
    #
    my $repo_head = qx{ curl -sSL --head $DOT_REPO };
    if ($repo_head =~ /HTTP.. 2\d\d/) {
        info "Dotfiles repo URL is valid.";
    } else {
        bad "Dotfiles repo URL is invalid.";
        say "HEAD $DOT_REPO";
        say $repo_head;
    }
    #
    # Is dotfiles installed?
    #
    my $root = dot_root;
    unless (defined $root) {
        bad "Dotfiles isn't installed üëé";
        return;
    }
    good "Dotfiles is installed üëç";
    info "Location: $root";
    #
    # List dotfiles
    #
    my @dotfiles = dot_files;
    info "Tracking " . scalar @dotfiles . " dotfiles.";
    say bold "Dotfiles";
    say for @dotfiles;
    #
    # Git status/update
    #
    chdir() or die $!;
    my $git = dot_git;
    my $status = qx{ $git status --short };
    if ($status eq '') {
        info "Dotfiles are clean (no modifications).";
        say bold "Updating dotfiles repo";
        system "$git pull";
    } else {
        say bold "Repo Status:";
        system "$git status";
        warn "Cannot update dirty dotfiles.\n";
    }
}
#}}}


################################################################################
# Configurations
#
# User data configuration routines.
#
# The user configuration data structure looks like:
#
# {
#     <section name> => {
#         'DIR' => <workdir>
#         'RUN' => <command>
#         'CHECK => <command>
#         'DATA' => ( <list of data lines> )
#     }
# }
#
# Where all subsections are optional and may be undef.
#
#{{{

sub config {
    $_ = shift || die "Missing subcommand ‚úó\n";
    return conf_print(\%::CONF)    if /print/;
    return conf_validate(\%::CONF) if /validate/;
    die "Unknown subcommand: $_ ‚úó\n";
}

# conf_read FILE_NAME
#
# Read and parse the given file into the user configuration data
# structure.
#
sub conf_read {
    my ($fname) = @_;

    my $text;
    open(my $cfile, "<", $fname) or die qq(opening "$fname": $!);
    while (<$cfile>) {
        # Skip empty lines and comments
        next if /^(#(?!!).*|\s*)$/;
        # Remove leading whitespace and escaped newlines
        s/\\\n//g;
        $text .= $_;
    }
    close $cfile;

    my %conf;
    my $sect;
    for (split /\n/, $text) {
        #
        # New section with optional work directory.
        #
        if (/^\[(.*?(@(.*))?)\]/) {
            $sect = {};
            $conf{trim($1)} = $sect;
            if (defined $3) {
                $sect->{'DIR'} = trim($3 =~ s/~/$HOME/r);
            }
        }
        #
        # Non-data content of a section.
        #
        elsif (/^([A-Z]+): (.*)$/) {
            $sect->{$1} = trim($2);
        }
        #
        # Data content of a section.
        # 
        else {
            push @{$sect->{'DATA'}}, trim($_);
        }
    }

    return %conf;
}

# conf_print CONF
#
# Print the given user config data structure.
#
sub conf_print {
    my ($conf) = @_;

    if (!$conf) {
        say "<empty config>";
        return
    }

    for my $name (sort keys %{$conf}) {
        header $name;
        my $sect = $conf->{$name};
        for (keys %{$sect}) {
            say bold "$_:";
            my $val = $sect->{$_};
            if (ref($val) =~ m/ARRAY/) {
                say join("\n", @{$val});
            } else {
                say $val;
            }
        }
    }
}

# conf_validate CONF
#
# Validates the sections and subsections of the given user
# configuration data.
#
sub conf_validate {
    my ($conf) = @_;

    my %sections = (
        Get         => [ 'DIR', 'DATA' ],
        Install     => [ 'DIR', 'RUN', 'CHECK' ],
        Homebrew    => [ 'DIR', 'DATA' ]
    );

    for my $sec_name (keys %{$conf}) {
        $sec_name =~ /^(\w+)/;
        my $sec_type = $1;
        #
        # Validate section type.
        #
        unless (exists $sections{$sec_type}) {
            err qq(Unknown section type "$sec_type" in [$sec_name]);
            next;
        }
        #
        # Validate subsections.
        #
        while (my ($sub_name, $val) = each %{$conf->{$sec_name}}) {
            # Valid subsection name.
            unless(grep /$sub_name/, @{$sections{$sec_type}}) {
                err qq(Invalid subsection "$sub_name" in [$sec_name]);
            }
            # Directories exists.
            elsif ($sub_name eq 'DIR') {
                err qq(Workdir not found "$val" for [$sec_name])
                    unless -d $val;
            }
        }
    }
}
#}}}


################################################################################
# Data
#{{{
#}}}


################################################################################
# Main
#{{{

mkdir "$HOME/.cache", 0755 unless -d "$HOME/.cache";
mkdir "$HOME/.config", 0755 unless -d "$HOME/.config";
mkdir $CACHE_DIR, 0755 unless -d $CACHE_DIR;
mkdir $CONF_DIR, 0755 unless -d $CONF_DIR;
mkdir $TMP_DIR, 0755 unless -d $TMP_DIR;

dbmopen(our %DATA, $APP_DATA_FILE, 0644);

our %CONF;
%CONF = conf_read $USER_CONF_FILE if -f $USER_CONF_FILE;

# Rogu is only intended to be used interactively, so
# don't bother with using both STDERR and STDOUT.
# The output shouldn't be redirected anyway.
set_log_out(*STDOUT);

my $MAN = 0;
my $HELP = 0;
my $DEBUG = 0;

GetOptions('help|h' => \$HELP, 'man' => \$MAN, 'debug|d', \$DEBUG)
    or pod2usage(2);
pod2usage( -exitval  => 0, -verbose  => 2)
    if $MAN;
pod2usage( -verbose  => 99, -sections => "SYNOPSIS|Commands|OPTIONS")
    if $HELP || !(scalar @ARGV);

my $CMD = shift;
my $ARGS = join '", "', @ARGV;
my @RES = eval "$CMD(\"$ARGS\")";
if ($DEBUG && @RES) {
    use Data::Dumper;
    say Dumper(@RES);
}
#}}}


################################################################################
# Help text
#{{{

__END__
=head1 NAME

rogu - Roger's weird offspring.

=head1 SYNOPSIS

rogu [options] <command> [args...]

=head1 Commands

=over 8

=item B<conf> <cmd>

Configuration stuff.

=back

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<This program> will read the given input file(s) and do something
useful with the contents thereof.

=cut #}}}
